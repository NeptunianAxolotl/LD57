
local Font = require("include/font")local SurfaceDefs, SurfaceDefNames = util.LoadDefNames("defs/surfaceDefs")

local MapDefs = util.LoadDefDirectory("defs/maps")

local self = {}
local api = {}
---------------------------------------------------- Util--------------------------------------------------local function DistSqTo(data, pos)	return util.DistSqVectors(data.pos, pos)endlocal function GetClosestShape(pos)	local closePoly, polyDist = IterableMap.GetMinimum(self.polygons, DistSqTo, pos)	local closeCircle, circleDist = IterableMap.GetMinimum(self.circles, DistSqTo, pos)	if not (polyDist or circleDist) then		return false	end	if (not circleDist) or circleDist > polyDist then		return {			shape = "poly",			key = closePoly.map_key,		}	end	return {		shape = "circle",		key = closeCircle.map_key,	}end---------------------------------------------------- Initialisation--------------------------------------------------local function SetupSurface(fixture, surface)	local def = SurfaceDefNames[surface]	fixture:setFriction(def.friction)	fixture:setRestitution(def.bounce)endlocal function NewPolygon(points, surface)	surface = surface or "default"	local flatVerts = {}	local left, right, top, bot = points[1][1], points[1][1], points[1][2], points[1][2]	for i = 1, #points do		flatVerts[#flatVerts + 1] = points[i][1]		flatVerts[#flatVerts + 1] = points[i][2]		left, right = math.min(left, points[i][1]), math.max(right, points[i][1])		top, bot = math.min(top, points[i][2]), math.max(bot, points[i][2])	end	local pos = {(left + right)/2, (top + bot)/2}		local body = love.physics.newBody(self.world.GetPhysicsWorld(), 0, 0, "static")	local shape = love.physics.newPolygonShape(unpack(flatVerts))	local fixture = love.physics.newFixture(body, shape, 1)	SetupSurface(fixture, surface)		local drawVerts = {}	for i = 1, #points do		drawVerts[#drawVerts + 1] = points[i][1]		drawVerts[#drawVerts + 1] = points[i][2]	end		local polygon = {		points = points,		drawVerts = drawVerts,		body = body,		shape = shape,		pos = pos,		surface = surface,	}	IterableMap.Add(self.polygons, polygon)endlocal function NewCircle(pos, radius, surface)	surface = surface or "default"	local body = love.physics.newBody(self.world.GetPhysicsWorld(), pos[1], pos[2], "static")	local shape = love.physics.newCircleShape(radius)	local fixture = love.physics.newFixture(body, shape, 1)	SetupSurface(fixture, surface)	local circle = {		pos = pos,		radius = radius,		body = body,		circle = body,		surface = surface,	}	IterableMap.Add(self.circles, circle)end---------------------------------------------------- Level Editing--------------------------------------------------function api.SaveLevel(name)	love.filesystem.createDirectory("levels")	local save = {		polygons = {},		circles = {},	}	for _, polygon in IterableMap.Iterator(self.polygons) do		save.polygons[#save.polygons + 1] = {			points = util.CopyTable(polygon.points),			surface = polygon.surface,		}	end	for _, circle in IterableMap.Iterator(self.circles) do		save.circles[#save.circles + 1] = {			pos = circle.pos,			radius = circle.radius,			surface = circle.surface,		}	end		local saveTable = util.TableToString(save, Global.SAVE_ORDER, util.ListToMask(Global.SAVE_INLINE))	saveTable = "local data = " .. saveTable .. [[return data]]	local success, message = love.filesystem.write("levels/" .. name .. ".lua", saveTable)	if success then		EffectsHandler.SpawnEffect("error_popup", {900, 15}, {text = "Level saved to " .. (love.filesystem.getSaveDirectory() or "DIR_ERROR") .. "/" .. name .. ".", velocity = {0, 4}})	else		EffectsHandler.SpawnEffect("error_popup", {900, 15}, {text = "Save error: " .. (message or "NO MESSAGE"), velocity = {0, 4}})	end	return successendfunction api.MousePressed(x, y, button)	if not self.world.GetEditMode() then		return false	end	if self.editMode == "poly" then		if button == 2 then			if self.placingPoly and #self.placingPoly > 2 then				NewPolygon(self.placingPoly)				self.placingPoly = false			end		elseif (not self.placingPoly) or #self.placingPoly < 8 then			self.placingPoly = self.placingPoly or {}			self.placingPoly[#self.placingPoly + 1] = self.world.GetMousePosition()			if not util.ArePointsConvex(self.placingPoly) then				self.placingPoly[#self.placingPoly] = nil			end		end	elseif self.editMode == "circle" then		if button == 2 then			self.placingCircle = false		elseif self.placingCircle then			local radius = util.DistVectors(self.placingCircle, self.world.GetMousePosition())			if radius > 10 then				NewCircle(self.placingCircle, radius)				self.placingCircle = false			end		else			self.placingCircle = self.world.GetMousePosition()		end	elseif self.editMode == "delete" then		if self.closeShape.shape == "circle" then			IterableMap.Get(self.circles, self.closeShape.key).body:destroy()			IterableMap.Remove(self.circles, self.closeShape.key)		elseif self.closeShape.shape == "poly" then			IterableMap.Get(self.polygons, self.closeShape.key).body:destroy()			IterableMap.Remove(self.polygons, self.closeShape.key)		end	endendfunction api.KeyPressed(key, scancode, isRepeat)	if not self.world.GetEditMode() then		return false	end	if key == "v" then		self.editMode = "poly"		if self.placingPoly and #self.placingPoly > 0 then			self.placingPoly[#self.placingPoly] = nil		else			self.placingPoly = false		end	elseif key == "c" then		self.editMode = "circle"		self.placingCircle = false	elseif key == "k" then		api.SaveLevel("level")	elseif key == "r" then		self.editMode = "delete"	endend---------------------------------------------------- Updates--------------------------------------------------

function api.UpdateSpeedLimit(body)
	local vx, vy = body:getLinearVelocity()
	local speedSq = util.DistSq(0, 0, vx, vy)
	if speedSq < Global.SPEED_LIMIT * Global.SPEED_LIMIT then
		body:setLinearDamping(0)
		return
	end
	local speed = math.sqrt(speedSq)
	body:setLinearDamping((speed - Global.SPEED_LIMIT) / Global.SPEED_LIMIT)
end

local function SetupLevel(levelData)
	for i = 1, #levelData.polygons do		NewPolygon(levelData.polygons[i].points, levelData.polygons[i].surface)	end	for i = 1, #levelData.circles do		NewCircle(levelData.circles[i].pos, levelData.circles[i].radius, levelData.circles[i].surface)	end
end

function api.Draw(drawQueue)
	drawQueue:push({y=0; f=function()		self.closeShape = false		if self.editMode == "delete" and self.world.GetEditMode() then			self.closeShape = GetClosestShape(self.world.GetMousePosition())		end		Font.SetSize(3)		local _, circleKey, circleData = IterableMap.GetBarbarianData(self.circles)		for i = 1, #circleKey do			local circle = circleData[circleKey[i]]			if self.closeShape and self.closeShape.shape == "circle" and self.closeShape.key == circleKey[i] then				love.graphics.setColor(1, 0.1, 0.1, 1)				local pos = self.world.GetMousePosition()				love.graphics.line(pos[1], pos[2], circle.pos[1], circle.pos[2])			else				love.graphics.setColor(1, 1, 1, 1)			end			love.graphics.circle("line", circle.pos[1], circle.pos[2], circle.radius)			love.graphics.printf(circle.surface, circle.pos[1], circle.pos[2], 500)		end		local _, polyKey, polyData = IterableMap.GetBarbarianData(self.polygons)		for i = 1, #polyKey do			local polygon = polyData[polyKey[i]]			if self.closeShape and self.closeShape.shape == "poly" and self.closeShape.key == polyKey[i] then				love.graphics.setColor(1, 0.1, 0.1, 1)				local pos = self.world.GetMousePosition()				love.graphics.line(pos[1], pos[2], polygon.pos[1], polygon.pos[2])			else				love.graphics.setColor(1, 1, 1, 1)			end			love.graphics.polygon("line", unpack(polygon.drawVerts))			love.graphics.printf(polygon.surface, polygon.pos[1] - 250, polygon.pos[2] - 20, 500, "center")		end				love.graphics.setColor(0.5, 1, 0.5, 1)		if self.world.GetEditMode() then			if self.editMode == "poly" and self.placingPoly and #self.placingPoly > 0 then				for i = 1, #self.placingPoly - 1 do					local thisVert = self.placingPoly[i]					local nextVert = self.placingPoly[i+1]					love.graphics.line(thisVert[1], thisVert[2], nextVert[1], nextVert[2])				end				local pos = self.world.GetMousePosition()				local thisVert = self.placingPoly[#self.placingPoly]				love.graphics.line(thisVert[1], thisVert[2], pos[1], pos[2])			elseif self.editMode == "circle" and self.placingCircle then				local radius = util.DistVectors(self.placingCircle, self.world.GetMousePosition())				love.graphics.circle("line", self.placingCircle[1], self.placingCircle[2], radius)			end		end
	end})
end

function api.Initialize(world, levelData)
	self = {
		world = world,		circles = IterableMap.New(),		polygons = IterableMap.New(),
	}
	
	SetupLevel(levelData)
end

return api
